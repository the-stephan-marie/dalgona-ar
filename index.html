<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR AR Model Viewer</title>
    
    <!-- Model Viewer Script -->
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.3.0/model-viewer.min.js"></script>
    
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="model-container">
        <model-viewer
            id="model-viewer"
            src="models/Dalgona-OneTake_0004.glb"
            ios-src="models/Dalgona-OneTake_0004.usdz"
            alt="Dalgona OneTake Model"
            ar
            ar-modes="webxr scene-viewer quick-look"
            ar-scale="auto"
            ar-placement="floor"
            link="https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona"
            title="Discover 30 days of Nescafe recipes this Ramadan."
            camera-controls
            auto-rotate
            autoplay
            animation-name="animation_0"
            shadow-intensity="1"
            exposure="1"
            environment-image="neutral"
            style="width: 100%; height: 100vh; background-color: #f0f0f0;">
            
            <button slot="ar-button" class="ar-button">
                View in AR
            </button>
            
            <div slot="poster" class="poster">
                <div class="poster-content">
                    <p>Loading 3D Model...</p>
                </div>
            </div>
            
            <!-- WebXR Banner for Android - Must be inside model-viewer -->
            <div id="webxr-banner" class="webxr-banner">
                <div class="banner-content">
                    <div class="banner-text">
                        <h3 class="banner-title">Dalgona Coffee with Nescafe</h3>
                        <p class="banner-subtitle">Discover 30 days of Nescafe recipes this Ramadan.</p>
                    </div>
                    <a href="https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona" 
                       class="banner-button" 
                       id="banner-action-button"
                       target="_blank" 
                       rel="noopener noreferrer">
                        Try Now!
                    </a>
                </div>
            </div>
        </model-viewer>
        
    </div>

    <script>
        // iOS Quick Look Banner Configuration
        const iosBannerConfig = {
            // Generic Banner Options
            callToAction: 'Try Now!',
            checkoutTitle: 'Dalgona Coffee with Nescafe',
            checkoutSubtitle: 'Discover 30 days of Nescafe recipes this Ramadan.',
            price: '',
            canonicalWebPageURL: 'https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona',
            
            // Custom HTML Banner Options (alternative to generic)
            // Uncomment to use custom HTML banner instead
            // custom: "https://example.com/banner.html",
            // customHeight: "medium" // small, medium, or large
        };

        // WebXR Banner Configuration for Android
        const webxrBannerConfig = {
            title: 'Dalgona Coffee with Nescafe',
            subtitle: 'Discover 30 days of Nescafe recipes this Ramadan.',
            buttonText: 'Try Now!',
            actionURL: 'https://www.nescafe.com/mena/en-ae/recipes/nescafe-3in1-dalgona'
        };

        // Build iOS USDZ URL with banner parameters
        // CRITICAL: iOS Quick Look requires ABSOLUTE URLs for banner parameters to work
        function buildIOSQuickLookURL() {
            let iosUrl = "models/Dalgona-OneTake_0004.usdz";
            
            // Convert relative path to absolute URL if needed
            if (!iosUrl.startsWith('http://') && !iosUrl.startsWith('https://')) {
                // Use current origin to create absolute URL
                const baseUrl = window.location.origin;
                const path = iosUrl.startsWith('/') ? iosUrl : `/${iosUrl}`;
                iosUrl = `${baseUrl}${path}`;
            }
            
            const params = [];
            
            // Use custom HTML banner if specified
            if (iosBannerConfig.custom) {
                params.push(`custom=${encodeURIComponent(iosBannerConfig.custom)}`);
                if (iosBannerConfig.customHeight) {
                    params.push(`customHeight=${iosBannerConfig.customHeight}`);
                }
            } else {
                // Use generic banner
                if (iosBannerConfig.callToAction) {
                    params.push(`callToAction=${encodeURIComponent(iosBannerConfig.callToAction)}`);
                }
                if (iosBannerConfig.checkoutTitle) {
                    params.push(`checkoutTitle=${encodeURIComponent(iosBannerConfig.checkoutTitle)}`);
                }
                if (iosBannerConfig.checkoutSubtitle) {
                    params.push(`checkoutSubtitle=${encodeURIComponent(iosBannerConfig.checkoutSubtitle)}`);
                }
                if (iosBannerConfig.price) {
                    params.push(`price=${encodeURIComponent(iosBannerConfig.price)}`);
                }
                if (iosBannerConfig.canonicalWebPageURL) {
                    params.push(`canonicalWebPageURL=${encodeURIComponent(iosBannerConfig.canonicalWebPageURL)}`);
                }
            }
            
            // Append parameters to USDZ URL with #
            if (params.length > 0) {
                iosUrl = `${iosUrl}#${params.join('&')}`;
            }
            
            return iosUrl;
        }

        // Set the iOS source URL with banner parameters
        // CRITICAL: Set ios-src immediately so iOS can detect AR capability
        const modelViewer = document.getElementById('model-viewer');
        
        // Build iOS URL with banner parameters
        const iosUrl = buildIOSQuickLookURL();
        console.log('iOS Quick Look URL:', iosUrl);
        console.log('Protocol:', window.location.protocol);
        console.log('Host:', window.location.host);
        
        // Set ios-src immediately - iOS needs this to detect AR capability
        // iOS Quick Look requires HTTPS (except localhost)
        if (window.location.protocol === 'https:' || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            modelViewer.setAttribute('ios-src', iosUrl);
            console.log('âœ… ios-src set:', modelViewer.getAttribute('ios-src'));
        } else {
            console.warn('âš ï¸ iOS Quick Look requires HTTPS. Current protocol:', window.location.protocol);
            // Still set it, but warn user
            modelViewer.setAttribute('ios-src', iosUrl);
        }
        
        // Verify AR availability
        modelViewer.addEventListener('load', () => {
            console.log('Model loaded. AR available:', modelViewer.arAvailable);
            console.log('AR modes:', modelViewer.arModes);
            console.log('Current ios-src:', modelViewer.getAttribute('ios-src'));
            
            // Update URL after load to ensure banner parameters are included
            const updatedUrl = buildIOSQuickLookURL();
            if (modelViewer.getAttribute('ios-src') !== updatedUrl) {
                modelViewer.setAttribute('ios-src', updatedUrl);
                console.log('Updated ios-src:', updatedUrl);
            }
        }, { once: true });

        // Listen for banner tap events
        // Note: This requires the model-viewer to be wrapped in an anchor tag for iOS Quick Look
        // For model-viewer, we need to listen on the model-viewer element itself
        modelViewer.addEventListener('message', function(event) {
            if (event.data === '_apple_ar_quicklook_button_tapped') {
                console.log('iOS Quick Look banner tapped!');
                // Handle banner tap - redirect or perform action
                // You can customize this behavior
                if (iosBannerConfig.canonicalWebPageURL) {
                    // Optionally redirect or perform custom action
                    // window.location.href = iosBannerConfig.canonicalWebPageURL;
                }
            }
        }, false);

        // Listen for AR session events
        modelViewer.addEventListener('ar-status', function(event) {
            const status = event.detail.status;
            const mode = event.detail.mode || 'unknown';
            const banner = document.getElementById('webxr-banner');
            
            console.log('AR Status:', status, 'Mode:', mode);
            
            // Enable features whenever AR is active - don't gatekeep based on mode detection
            if (status === 'session-started' || status === 'object-placed' || status === 'presenting') {
                // Show banner - will work in WebXR, won't show in native apps (which is fine)
                if (banner) {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            banner.style.display = 'flex';
                            banner.style.position = 'fixed';
                            banner.style.bottom = '20px';
                            banner.style.left = '50%';
                            banner.style.transform = 'translateX(-50%)';
                            banner.style.zIndex = '99999';
                            banner.style.visibility = 'visible';
                            banner.style.opacity = '1';
                            banner.style.width = '90%';
                            banner.style.maxWidth = '500px';
                            banner.style.background = 'white';
                            banner.style.padding = '16px 20px';
                            banner.style.borderRadius = '10px';
                            banner.style.boxShadow = '0 4px 10px rgba(0, 0, 0, 0.2)';
                        });
                    });
                }
            } else if (status === 'not-presenting' || 
                       status === 'session-ended' ||
                       status === 'failed') {
                if (banner) banner.style.display = 'none';
            }
        });

        // Update WebXR banner content
        function updateWebXRBanner() {
            const bannerTitle = document.querySelector('.banner-title');
            const bannerSubtitle = document.querySelector('.banner-subtitle');
            const bannerButton = document.getElementById('banner-action-button');
            
            if (bannerTitle) bannerTitle.textContent = webxrBannerConfig.title;
            if (bannerSubtitle) bannerSubtitle.textContent = webxrBannerConfig.subtitle;
            if (bannerButton) bannerButton.textContent = webxrBannerConfig.buttonText;
        }

        // Handle WebXR banner button click
        // Prevent clicks on banner from bubbling to viewer and triggering raycasts
        const banner = document.getElementById('webxr-banner');
        if (banner) {
            // Stop all events on banner from propagating
            ['click', 'touchstart', 'touchend'].forEach(eventType => {
                banner.addEventListener(eventType, function(event) {
                    event.stopPropagation();
                    event.stopImmediatePropagation();
                }, { capture: true });
            });
        }
        

        // Initialize banner content
        updateWebXRBanner();
        
        // Debug: Log banner setup
        const bannerElement = document.getElementById('webxr-banner');
        console.log('=== WebXR Banner Debug ===');
        console.log('Banner element:', bannerElement);
        console.log('Banner parent:', bannerElement?.parentElement);
        console.log('Banner is inside model-viewer:', modelViewer.contains(bannerElement));
        console.log('Banner computed display:', bannerElement ? window.getComputedStyle(bannerElement).display : 'N/A');
        console.log('Model viewer AR available:', modelViewer.arAvailable);
        console.log('Model viewer AR modes:', modelViewer.arModes);

        // Monitor visibility changes to hide banner when user leaves (e.g., to native AR app)
        document.addEventListener('visibilitychange', function() {
            const banner = document.getElementById('webxr-banner');
            if (document.hidden) {
                // Page is hidden - likely user went to native AR app
                if (banner) banner.style.display = 'none';
            }
        });
        
        // Additional check: Monitor AR mode changes
        modelViewer.addEventListener('ar-mode', function(event) {
            console.log('AR Mode changed:', event.detail);
            const banner = document.getElementById('webxr-banner');
            if (event.detail === 'webxr' && banner) {
                // Ensure banner is visible for WebXR
                setTimeout(() => {
                    if (modelViewer.getAttribute('ar-status') === 'presenting' || 
                        modelViewer.getAttribute('ar-status') === 'session-started') {
                        banner.style.display = 'flex';
                    }
                }, 100);
            }
        });

        // ============================================
        // AR RAYCAST TOUCH DETECTION WITH VISUALIZATION
        // ============================================
        
        let THREE = null;
        let raycaster = null;
        let scene = null;
        let camera = null;
        let renderer = null;
        let rayLines = [];
        let isInARMode = false;
        let hierarchyNodes = [];
        
        // Initialize Three.js and raycasting
        async function initializeRaycasting() {
            if (!window.THREE) {
                THREE = await import('https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js');
                window.THREE = THREE;
            } else {
                THREE = window.THREE;
            }
            
            raycaster = new THREE.Raycaster();
            console.log('âœ… Three.js and Raycaster initialized');
        }
        
        // Setup hit detection when model loads
        modelViewer.addEventListener('load', () => {
            setupHitDetection();
        });
        
        modelViewer.addEventListener('scene-graph-ready', () => {
            setupHitDetection();
        });
        
        function setupHitDetection() {
            if (!THREE) {
                initializeRaycasting().then(() => {
                    setupHitDetection();
                });
                return;
            }
            
            if (!modelViewer.loaded) {
                modelViewer.addEventListener('load', setupHitDetection, { once: true });
                return;
            }
            
            try {
                // Access model hierarchy
                const symbols = Object.getOwnPropertySymbols(modelViewer.model);
                const hierarchySym = symbols.find(s => s.toString().includes('hierarchy'));
                
                if (hierarchySym) {
                    const hierarchy = modelViewer.model[hierarchySym];
                    hierarchyNodes = hierarchy.filter(node => node.mesh);
                    console.log('âœ… Found', hierarchyNodes.length, 'nodes with meshes');
                    
                    // Get scene and camera from model-viewer - try multiple times if needed
                    function getSceneAndCamera() {
                        if (modelViewer.renderRoot) {
                            const canvas = modelViewer.renderRoot.querySelector('canvas');
                            if (canvas && canvas.__THREE__) {
                                scene = canvas.__THREE__.scene;
                                camera = canvas.__THREE__.camera;
                                renderer = canvas.__THREE__.renderer;
                                console.log('âœ… Got Three.js scene, camera, and renderer from model-viewer');
                                return true;
                            }
                        }
                        return false;
                    }
                    
                    if (!getSceneAndCamera()) {
                        // Retry after a short delay
                        setTimeout(() => {
                            getSceneAndCamera();
                        }, 500);
                    }
                }
            } catch (error) {
                console.error('Error setting up hit detection:', error);
            }
        }
        
        // Find hit object using raycasting
        function findHitObject(clientX, clientY) {
            if (!raycaster || !camera || !hierarchyNodes.length || !scene) {
                return null;
            }
            
            const rect = modelViewer.getBoundingClientRect();
            const x = ((clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            // Update camera from model-viewer's camera
            if (modelViewer.renderRoot) {
                const canvas = modelViewer.renderRoot.querySelector('canvas');
                if (canvas && canvas.__THREE__) {
                    const threeCamera = canvas.__THREE__.camera;
                    if (threeCamera) {
                        camera.position.copy(threeCamera.position);
                        camera.quaternion.copy(threeCamera.quaternion);
                        camera.updateMatrixWorld();
                    }
                }
            }
            
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            
            // Get all meshes from hierarchy
            const meshes = hierarchyNodes
                .map(node => node.mesh)
                .filter(mesh => mesh && mesh.isMesh);
            
            const intersects = raycaster.intersectObjects(meshes, true);
            
            if (intersects.length > 0) {
                const hit = intersects[0];
                const hitMesh = hit.object;
                
                // Find which node this mesh belongs to
                const hitNode = hierarchyNodes.find(node => {
                    if (node.mesh === hitMesh) return true;
                    let parent = hitMesh.parent;
                    while (parent) {
                        if (node.mesh === parent) return true;
                        parent = parent.parent;
                    }
                    return false;
                });
                
                return {
                    node: hitNode,
                    mesh: hitMesh,
                    point: hit.point,
                    distance: hit.distance,
                    name: hitNode?.name || hitMesh.name || 'Unknown'
                };
            }
            
            return null;
        }
        
        // Create visual ray
        function createRayVisual(startPoint, endPoint, hit = false) {
            if (!THREE) return null;
            
            // Ensure we have access to scene
            if (!scene && modelViewer.renderRoot) {
                const canvas = modelViewer.renderRoot.querySelector('canvas');
                if (canvas && canvas.__THREE__) {
                    scene = canvas.__THREE__.scene;
                }
            }
            
            if (!scene) {
                console.warn('Scene not available for ray visualization');
                return null;
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(startPoint.x, startPoint.y, startPoint.z),
                new THREE.Vector3(endPoint.x, endPoint.y, endPoint.z)
            ]);
            
            const material = new THREE.LineBasicMaterial({
                color: hit ? 0x00ff00 : 0xff0000,
                linewidth: 5,
                transparent: true,
                opacity: 0.9
            });
            
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            rayLines.push(line);
            
            // Remove ray after 2 seconds (longer visibility)
            setTimeout(() => {
                if (scene && line.parent) {
                    scene.remove(line);
                    line.geometry.dispose();
                    line.material.dispose();
                }
                const index = rayLines.indexOf(line);
                if (index > -1) rayLines.splice(index, 1);
            }, 2000);
            
            return line;
        }
        
        // Handle touches/clicks in AR mode
        function handleARTouch(event) {
            if (!isInARMode) return;
            
            // Don't interfere with UI elements (banner)
            const target = event.target;
            if (target.closest('#webxr-banner')) {
                return; // Let UI elements handle their own events
            }
            
            // Only prevent default on touchstart, not touchend (touchend can't be cancelled during scroll)
            if (event.type === 'touchstart' && event.cancelable) {
                event.preventDefault();
            }
            
            // Get touch/click coordinates
            let clientX, clientY;
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event.changedTouches && event.changedTouches.length > 0) {
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }
            
            // Find hit object
            const hit = findHitObject(clientX, clientY);
            
            if (hit && camera && scene) {
                // Create ray visual
                const cameraPos = camera.position.clone();
                const hitPoint = hit.point;
                createRayVisual(cameraPos, hitPoint, true);
                
                console.log('ðŸŽ¯ AR Touch Hit:', hit.name, 'distance:', hit.distance.toFixed(2) + 'm');
            } else {
                // Miss - create ray to far point
                if (camera && scene) {
                    const cameraPos = camera.position.clone();
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    const farPoint = cameraPos.clone().add(direction.multiplyScalar(10));
                    createRayVisual(cameraPos, farPoint, false);
                    
                    console.log('âŒ AR Touch Miss: No object hit');
                }
            }
        }
        
        // Listen for AR status to enable/disable touch detection
        // Don't gatekeep - enable whenever AR is active regardless of mode detection
        modelViewer.addEventListener('ar-status', (event) => {
            const status = event.detail.status;
            
            // Enable whenever AR is active - don't check mode
            if (status === 'presenting' || status === 'session-started' || status === 'object-placed') {
                isInARMode = true;
                
                // Add event listeners for AR touches
                // Use touchstart for raycasting (more reliable, can be cancelled)
                // Use click as fallback for mouse/pointer events
                modelViewer.addEventListener('click', handleARTouch, { passive: true });
                modelViewer.addEventListener('touchstart', handleARTouch, { passive: false });
            } else {
                isInARMode = false;
                
                // Remove event listeners
                modelViewer.removeEventListener('click', handleARTouch);
                modelViewer.removeEventListener('touchstart', handleARTouch);
                
                // Clean up ray visuals
                rayLines.forEach(line => {
                    if (scene && line.parent) {
                        scene.remove(line);
                        line.geometry.dispose();
                        line.material.dispose();
                    }
                });
                rayLines = [];
            }
        });
        
        // Initialize raycasting on page load
        initializeRaycasting();
        
        // ============================================
        // FIX ARIA-HIDDEN WARNING ON WEBXR EXIT BUTTON
        // ============================================
        // Model-viewer tries to set aria-hidden on the exit button while it has focus
        // This violates accessibility rules. We'll monitor and fix this.
        
        let exitButtonObserver = null;
        
        function fixAriaHiddenWarning() {
            // Find the WebXR exit button (model-viewer creates it dynamically)
            const exitButton = document.querySelector('#default-exit-webxr-ar-button') ||
                              document.querySelector('[id*="exit"][id*="webxr"]') ||
                              document.querySelector('[id*="exit"][id*="ar"]');
            
            if (!exitButton) {
                // Button not found yet, try again later
                return false;
            }
            
            // If we already have an observer, disconnect it
            if (exitButtonObserver) {
                exitButtonObserver.disconnect();
            }
            
            // Monitor for aria-hidden being set
            exitButtonObserver = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'aria-hidden') {
                        const isAriaHidden = exitButton.getAttribute('aria-hidden') === 'true';
                        const hasFocus = document.activeElement === exitButton;
                        
                        // If button has focus but aria-hidden is set, remove aria-hidden
                        // This prevents the accessibility warning
                        if (isAriaHidden && hasFocus) {
                            exitButton.removeAttribute('aria-hidden');
                        }
                    }
                });
            });
            
            // Observe the exit button for attribute changes
            exitButtonObserver.observe(exitButton, {
                attributes: true,
                attributeFilter: ['aria-hidden']
            });
            
            // Also handle focus events
            exitButton.addEventListener('focus', () => {
                const isAriaHidden = exitButton.getAttribute('aria-hidden') === 'true';
                if (isAriaHidden) {
                    exitButton.removeAttribute('aria-hidden');
                }
            }, { passive: true });
            
            return true;
        }
        
        // Try to fix the issue when AR status changes
        modelViewer.addEventListener('ar-status', () => {
            // Wait for model-viewer to create the exit button
            let attempts = 0;
            const maxAttempts = 10;
            const tryFix = () => {
                if (!fixAriaHiddenWarning() && attempts < maxAttempts) {
                    attempts++;
                    setTimeout(tryFix, 200);
                }
            };
            setTimeout(tryFix, 300);
        });
        
        // Also try on load and periodically
        const tryFixOnLoad = () => {
            let attempts = 0;
            const maxAttempts = 5;
            const tryFix = () => {
                if (!fixAriaHiddenWarning() && attempts < maxAttempts) {
                    attempts++;
                    setTimeout(tryFix, 500);
                }
            };
            tryFix();
        };
        
        if (modelViewer.loaded) {
            setTimeout(tryFixOnLoad, 1000);
        } else {
            modelViewer.addEventListener('load', () => {
                setTimeout(tryFixOnLoad, 1000);
            });
        }
    </script>
</body>
</html>

